import configparser
import psycopg2
import psycopg2.extras
# note: `pdfkit` requires wkhtmltopdf to be installed on the system via the 
# system package manager
from pdfkit import from_file as pdf_from_file
from pdfkit import from_string as pdf_from_string
from PyPDF2 import PdfFileReader, PdfFileWriter, PdfFileMerger
from io import BytesIO
from sys import exit
from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import letter
# we may be able to use io.BytesIO instead of tempfile, 
# but this works and may be faster
from tempfile import TemporaryFile
from jinja2 import Environment, FileSystemLoader
from datetime import datetime
from textwrap import dedent
from decimal import Decimal


# get the config info
config = configparser.ConfigParser()
config.read('config.ini')
db_connection_string = config['db']['connection_string']


def po_to_pdf(po_data, output_filename=None):
    # output options for the PDF generaton from 
    # more options here:
    # https://wkhtmltopdf.org/usage/wkhtmltopdf.txt
    options = {
        'encoding': 'UTF-8',
        'page-size': 'Letter',
        'margin-top': '0.75in',
        'margin-right': '0.25in',
        'margin-bottom': '0.75in',
        'margin-left': '0.25in'
    }

    # set up the template
    env = Environment(
        loader=FileSystemLoader('./templates', encoding='utf-8')
    )
    template = env.get_template('po_template.html')

    # add the total copies and the total value from the order subtotals 
    for order in po_data['orders']:
        
        # subtotal _maybe_ stored as a string, so we need to convert it to decimal
        # so that we can accumulate the total (kept as an example)
        # po_data['total'] = po_data['total'] + Decimal(sub(r'[^\d.]', '', order['subtotal']))
        
        po_data['total'] = ( Decimal(po_data['total']) + Decimal(order['subtotal']) )
        po_data['total_copies'] = po_data['total_copies'] + order['copies']

    # generate the temporary po data:
    # setting output_path=False will generate the pdf as a string
    # PREVIOUS method for generating the output was from a static html
    # pdfkit_output = pdf_from_file(
    #     input='po.html',
    #     output_path=False, 
    #     options=options
    # )

    # render the template to a string used by the input
    pdfkit_output = pdf_from_string(
        input=template.render(data=po_data),
        output_path=False,
        options=options
    )

    temp_file_po = TemporaryFile(mode='w+b')
    # write the contents to them temp file
    temp_file_po.write(pdfkit_output)
    # seek back to the start for reading
    temp_file_po.seek(0)

    # merge the temporary po pdf with the pre-existing signature pdf
    # (generated by adobe acrobat to tag the sig field)
    pdf_merger = PdfFileMerger()
    pdf_merger.append(temp_file_po)
    pdf_merger.append('./static_pdf/po_signaturefield.pdf')

    temp_file_merge = TemporaryFile(mode='w+b')
    pdf_merger.write(temp_file_merge)
    temp_file_merge.seek(0)

    # put page numbers and po number on every page ...
    pdf_reader = PdfFileReader(temp_file_merge)
    # temp_file.close()
    pdf_writer = PdfFileWriter()

    # place the purchase order number and the page number
    for page_num in range(pdf_reader.getNumPages()):
        # create a buffer to store the pdf canvas
        packet = BytesIO()
        # if we want to flip the orientation of the x,y cords, 
        # change "bottomup" to 0
        can = canvas.Canvas(packet, 
            pagesize=letter, 
            bottomup=1
        )
        can.setFont('Courier', 12)
        # place the purchase order number
        can.drawString(25,10, 
            "Purchase Order Number: {} page {} of {}".format(
                po_data['po_number'],
                (page_num + 1),
                pdf_reader.getNumPages()
            )
        )
        can.save()
        packet.seek(0)
        input = PdfFileReader(packet)
        # merge (or, watermark) the input page with the original document
        page = pdf_reader.getPage(page_num)
        page.mergePage(input.getPage(0))
        pdf_writer.addPage(page)

    if (output_filename == None):
        # set a default file name of the current timestamp + po number + .pdf
        output_filename = (
            # prevent microseconds from appearing in the filename
            'po-' 
            + po_data['po_number']
            + '-'
            + datetime.now().replace(microsecond=0).isoformat()
            + '.pdf'
        )

    with open(output_filename, 'wb') as out:
        pdf_writer.write(out)

    temp_file_po.close()
    temp_file_merge.close()

    print('{} :Done'.format(po_data['po_number']))
    
    # end po_to_pdf


# test it...
# po_to_pdf(po_data)

# this is the list we'll use to generate our POs from
po_data_list = []

# connect to the database
try:
    pgsql_conn = psycopg2.connect(db_connection_string)
except psycopg2.Error as e:
    print("unable to connect to sierra database: %s" % e)
    # exit indicating an issue...
    exit(1)

# create the temp tables on the database:
sql_string = open(
    './purchase_order_temp_tables.sql',
    mode='r', 
    encoding='utf-8-sig'
).read()

try:
    with pgsql_conn as conn:
        with conn.cursor() as cursor:
            cursor.execute(sql_string)
except psycopg2.Error as e:
    print("psycopg2 Error: {}".format(e))


# return a list (of tuples) of distinct purchase orders
purchase_orders = None
sql = """
SELECT
DISTINCT t.blanket_purchase_order_num
FROM
temp_order_record_info as t
ORDER BY
t.blanket_purchase_order_num
;
""".strip()
try:
    with pgsql_conn as conn:
        with conn.cursor() as cursor:
            cursor.execute(sql)
            purchase_orders = cursor.fetchall()
except psycopg2.Error as e:
    print("psycopg2 Error: {}".format(e))


# GENERATE THE PO DICT
# iterate over the list of distinct purchase orders
for purchase_order in purchase_orders:
    # print(purchase_order[0])
    sql = """
    SELECT
    t.order_record_id,
    t.bib_record_id,
    t.order_record_num,
    t.vendor_record_code,
    t.bib_record_num,
    t.isbn,
    t.best_title,
    t.order_note,
    t.best_author,
    t.order_date,
    t.record_last_updated_gmt,
    t.form_code,
    t.order_status_code,
    t.blanket_purchase_order_num,
    t.fund_code,
    t.code,
    t.estimated_price,
    t.copies,
    t.subtotal

    FROM 
    temp_order_record_info as t

    WHERE
    t.blanket_purchase_order_num = %s

    ORDER BY
    t.order_record_num
    """.strip()
    try:
        with pgsql_conn as conn:
            with conn.cursor(name='orders_cursor', cursor_factory=psycopg2.extras.DictCursor) as cursor:
                cursor.execute(
                    sql,
                    (purchase_order[0],)
                )
                orders = cursor.fetchall()
    except psycopg2.Error as e:
        print("psycopg2 Error: {}".format(e))

    # get the vendor data from the first order record ...
    vendor_address = None
    sql = """
    SELECT
    t.vendor_record_id,
    t.code,
    t.display_order,
    t.addr1,
    t.addr2,
    t.addr3,
    t.village,
    t.city,
    t.region,
    t.postal_code,
    t.country

    FROM
    temp_vendor_record_address as t
    WHERE
    t.code = %s
    
    ORDER BY display_order

    LIMIT 1
    """.strip()
    try:
        with pgsql_conn as conn:
            with conn.cursor(name='vendors_cursor', cursor_factory=psycopg2.extras.DictCursor) as cursor:
                cursor.execute(
                    sql,
                    # vendor_record_code comes from the first 
                    (orders[0]['vendor_record_code'],)
                )
                vendor_address = cursor.fetchone()
    except psycopg2.Error as e:
        print("psycopg2 Error: {}".format(e))

    # set the po dictionary values for the purchase order number, and the vendor address info
    po_data = {
        "po_number": purchase_order[0],
        "vendor_addr1": vendor_address['addr1'],
        "vendor_addr2": vendor_address['addr2'],
        "vendor_addr3": vendor_address['addr3'],
        "vendor_city": vendor_address['city'],
        "vendor_region": vendor_address['region'],
        "vendor_postal_code": vendor_address['postal_code'],
        'total': 0.00,
        'total_copies': 0,
        'orders': [],
    }

    for order in orders:
        # print(order)
        order_dict = {
            "order_record_num": order['order_record_num'],
            "fund_code": order['fund_code'],
            "isbn": order['isbn'],
            "best_title": order['best_title'],
            "best_author": order['best_author'],
            "order_note": order['order_note'],
            "copies": order['copies'],
            "estimated_price": order['estimated_price'],
            "subtotal": order['subtotal'],
        }
        # append the order dictionary to the orders list
        po_data['orders'].append(order_dict)

    # # create the PDF!
    po_to_pdf(po_data)
    
    # append the pd data to a list
    po_data_list.append(po_data)

# from multiprocessing import Pool

# closing db connections
print("closing database connections...")
if pgsql_conn:
    if hasattr(pgsql_conn, 'close'):
        print("closing pgsql_conn")
        pgsql_conn.close()
pgsql_conn = None

# with Pool(8) as p:
#     print(p.map(po_to_pdf, po_data_list))
